#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <termios.h>
#include <unistd.h>

#include <signal.h>

#include <netinet/in.h>
#include <sys/socket.h>
#include <sys/types.h>

#include "config.h"
#include "database.h"
#include "protocol.h"
#include "types.h"
#include "utils.h"

#define SERVER_PORT 4242
#define BUFFER_SIZE 1024
#define LINE_WIDTH 80

PGconn* conn;
volatile sig_atomic_t running = 1;
status_t* response;
int sock;
user_t connected_user;

void display_menu_client();
void display_menu_pro();
void input(char* output)
{
    scanf("%s", output);
    getchar();
}

void display_choice_login()
{
    printf("--------------   LOGIN   -------------------\n");
    printf("[1] - connection client\n");
    printf("[2] - connection pro\n");
    printf("[3] - connection admin\n");
    printf("[4] - EXIT\n\n");
}

void connection_pro()
{
    char mail[CHAR_SIZE], token[API_TOKEN_SIZE];
    printf("Enter your email: ");
    input(mail);

    if (strcmp(mail, "o") == 0) {
        strcpy(mail, "brehat@gmail.com");
    }

    printf("Email entered: '%s'\n", mail);

    int user_found = db_get_user_by_email(conn, &connected_user, mail);

    if (!user_found) {
        printf("User not found\n");
        return;
    }
    printf("Token: %s\n", connected_user.api_token);
    send_login(sock, connected_user.api_token);
}

void connection_client()
{
    char mail[CHAR_SIZE], token[API_TOKEN_SIZE];

    printf("Enter your email: ");
    input(mail);

    if (strcmp(mail, "o") == 0) {
        strcpy(mail, "eliaz.chesnel@outlook.fr");
    }

    printf("Email entered: '%s'\n", mail);
    int user_found = db_get_user_by_email(conn, &connected_user, mail);

    if (!user_found) {
        printf("User not found\n");
        return;
    }
    printf("Token: %s\n", connected_user.api_token);
    send_login(sock, connected_user.api_token);
}
// generated by chatgpts
void enable_text_area_mode(struct termios* original)
{
    struct termios raw;
    tcgetattr(STDIN_FILENO, original);
    raw = *original;
    raw.c_lflag &= ~(ICANON | ECHO);
    tcsetattr(STDIN_FILENO, TCSANOW, &raw);
}

void reset_terminal_mode(struct termios* original)
{
    tcsetattr(STDIN_FILENO, TCSANOW, original);
}

void write_message(char* message)
{
    struct termios original;
    int index = 0;
    int line_pos = 0;
    int line_start[BUFFER_SIZE / LINE_WIDTH];
    int line_count = 1;
    char ch;

    enable_text_area_mode(&original);

    printf("Write your message (Ctrl+D to send, Backspace to delete):\n");

    line_start[0] = 0;

    while (1) {
        ch = getchar();

        if (ch == 4) { // Ctrl+D pour envoyer
            break;
        } else if (ch == 127) { // Backspace
            if (index > 0) {
                if (message[index - 1] == '\n') {
                    // Retour à la ligne précédente
                    if (line_count > 1) {
                        line_count--;
                        line_pos = index - line_start[line_count - 1];
                        printf("\033[F\033[%dC \033[D", line_pos); // Déplacer à la ligne précédente
                    }
                } else {
                    line_pos--;
                    printf("\b \b"); // Supprime le caractère précédent
                }
                index--;
            }
        } else if (ch == '\n') { // Retour à la ligne
            if (line_count < BUFFER_SIZE / LINE_WIDTH) {
                message[index++] = ch;
                line_start[line_count++] = index;
                printf("\n");
                line_pos = 0;
            }
        } else if (index < BUFFER_SIZE - 1) { // Saisie normale
            if (line_pos == LINE_WIDTH) { // Passage automatique à la ligne
                message[index++] = '\n';
                line_start[line_count++] = index;
                printf("\n");
                line_pos = 0;
            }
            message[index++] = ch;
            putchar(ch); // Affiche le caractère
            line_pos++;
        }
    }

    message[index] = '\0'; // Terminer le message
    reset_terminal_mode(&original);
}
void menu_message()
{
    char message[BUFFER_SIZE] = { 0 };
    int receiver_id;

    write_message(message);

    printf("\nMessage written:\n%s\n", message);

    printf("Enter the receiver id: ");
    scanf("%d", &receiver_id);
    getchar();

    if (receiver_id == 100) {
        receiver_id = 8;
    } else if (receiver_id == 200) {
        receiver_id = 11;
    }
}

void display_menu_client()
{
    printf("--------MENU CLIENT------\n");
    printf("[1] - send a message\n");
    printf("[2] - display unread messages\n");
    printf("[3] - modify a message\n");
    printf("[4] - delete a message\n");
    printf("[5] - display messages history\n");
    printf("[6] - EXIT\n\n");
}

void display_menu_pro()
{
    printf("------MENU PROFESSIONAL------\n");
    printf("[1] - send a message\n");
    printf("[2] - display unread messages\n");
    printf("[3] - modify a message\n");
    printf("[4] - delete a message\n");
    printf("[5] - display messages history\n");
    printf("[6] - EXIT\n\n");
}

void display_menu_admin()
{
    printf("------MENU ADMIN------\n");
    printf("[1] - send message\n");
    printf("[2] - block message\n");
    printf("[3] - ban user\n");
    printf("[4] - EXIT\n\n");
}

void disconnect(int sock)
{
    write(sock, "DISCONNECTED", 12);
    close(sock);
}

void signal_handler(int sig)
{
    if (sig == SIGINT) {
        disconnect(sock);
        running = 0;
        exit(EXIT_SUCCESS);
    }
}

void print_logo()
{
    printf(" //   _______   _           _        _\n");
    printf("//  |__   __| | |         | |      | |\n");
    printf("//     | | ___| |__   __ _| |_ __ _| |_ ___  _ __\n");
    printf("//     | |/ __| '_ \\ / _` | __/ _` | __/ _ \\| '__|\n");
    printf("//     | | (__| | | | (_| | || (_| | || (_) | |\n");
    printf("//     |_|\\___|_| |_|\\__,_|\\__\\__,_|\\__\\___/|_|\n\n");
}

int main()
{
    print_logo();
    int sock_ret;
    struct sockaddr_in server_addr;
    int choice;
    int is_connected = 0;
    connected_user = NOT_CONNECTED_USER;
    user_type_t user_type;

    config_t* config;
    config = malloc(sizeof(config_t));
    config_load(config);

    env_load("..");

    db_login(&conn);

    signal(SIGINT, signal_handler);

    // Create socket
    if ((sock = socket(AF_INET, SOCK_STREAM, 0)) < 0) {
        perror("Cannot create socket");
        exit(EXIT_FAILURE);
    }

    // Config server address
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(SERVER_PORT);
    server_addr.sin_addr.s_addr = INADDR_ANY;

    if ((sock_ret = connect(sock, (struct sockaddr*)&server_addr, sizeof(server_addr))) < 0) {
        perror("Cannot connect to the server socket");
        disconnect(sock);
        exit(EXIT_FAILURE);
    } else {
        printf("Connected to server ! .....\n");
    }

    while (running) {
        is_connected = memcmp(&connected_user, &NOT_CONNECTED_USER, sizeof(user_t)) != 0;

        if (response != NULL) {
            printf("\nResponse: %d %s\n", response->code, response->message);
        }

        if (is_connected) {
            user_type = db_get_user_type(conn, connected_user.id);

            if (user_type == MEMBER) {
                display_menu_client();
                printf("Enter your choice: ");
                scanf("%d", &choice);
                getchar();
                switch (choice) {
                case 1:
                    menu_message();
                    break;

                default:
                    printf("Invalid choice, please try again.\n");
                    break;
                }

            } else if (user_type == PROFESSIONAL) {
                display_menu_pro();
                printf("Enter your choice: ");
                scanf("%d", &choice);
                getchar();
                switch (choice) {
                case 1:
                    menu_message();
                    break;

                default:
                    printf("Invalid choice, please try again.\n");
                    break;
                }
            } else if (user_type == ADMIN) {
                display_menu_admin();
                printf("Enter your choice: ");
                scanf("%d", &choice);
                getchar();
            }

        } else {
            display_choice_login();
            printf("Enter your choice: ");
            scanf("%d", &choice);
            getchar();
            switch (choice) {
            case 1:
                connection_client();
                break;
            case 2:
                connection_pro();
                break;
            case 3:
                send_login(sock, config->admin_api_token);
                printf("Admin connected\n");
                break;
            case 4:
                disconnect(sock);
                return EXIT_SUCCESS;

            default:
                printf("Invalid choice, please try again.\n");
                break;
            }
        }
    }

    close(sock);
    return EXIT_SUCCESS;
}
